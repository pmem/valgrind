<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>14. Pmemcheck: persistent memory analyzer</title>
<link rel="stylesheet" type="text/css" href="vg_basic.css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="index.html" title="Valgrind Documentation">
<link rel="up" href="manual.html" title="Valgrind User Manual">
<link rel="prev" href="lk-manual.html" title="13. Lackey: an example tool">
<link rel="next" href="nl-manual.html" title="15. Nulgrind: the minimal Valgrind tool">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div><table class="nav" width="100%" cellspacing="3" cellpadding="3" border="0" summary="Navigation header"><tr>
<td width="22px" align="center" valign="middle"><a accesskey="p" href="lk-manual.html"><img src="images/prev.png" width="18" height="21" border="0" alt="Prev"></a></td>
<td width="25px" align="center" valign="middle"><a accesskey="u" href="manual.html"><img src="images/up.png" width="21" height="18" border="0" alt="Up"></a></td>
<td width="31px" align="center" valign="middle"><a accesskey="h" href="index.html"><img src="images/home.png" width="27" height="20" border="0" alt="Up"></a></td>
<th align="center" valign="middle">Valgrind User Manual</th>
<td width="22px" align="center" valign="middle"><a accesskey="n" href="nl-manual.html"><img src="images/next.png" width="18" height="21" border="0" alt="Next"></a></td>
</tr></table></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="pmc-manual"></a>14. Pmemcheck: persistent memory analyzer</h1></div></div></div>
<div class="toc">
<p><b>Table of Contents</b></p>
<dl class="toc">
<dt><span class="sect1"><a href="pmc-manual.html#pmc-manual.overview">14.1. Overview</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="pmc-manual.html#pmc-manual.functionality">14.1.1. Functionality</a></span></dt>
<dt><span class="sect2"><a href="pmc-manual.html#pmc-manual.basic_usage">14.1.2. Basic Usage</a></span></dt>
<dt><span class="sect2"><a href="pmc-manual.html#pmc-manual.error_types">14.1.3. Pmemcheck error types</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="pmc-manual.html#pmc-manual.options">14.2. Pmemcheck Command-line Options</a></span></dt>
<dt><span class="sect1"><a href="pmc-manual.html#pmc-manual.client_requests">14.3. Pmemcheck Client Requests</a></span></dt>
<dt><span class="sect1"><a href="pmc-manual.html#pmc-manual.monitor_commands">14.4. Pmemcheck Monitor Commands</a></span></dt>
</dl>
</div>
<p>
        To use this tool, you must specify<code class="option">--tool=pmemcheck</code>
        on the Valgrind command line.
    </p>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="pmc-manual.overview"></a>14.1. Overview</h2></div></div></div>
<p>
            Pmemcheck is a persistent memory profiler, which helps analyze the
            way user applications utilize persistent memory. It helps recognize
        	whether the correct store scheme is used and that data is made
        	persistent. With additional options it can also be used to log all
        	writes to a specific memory region and to identify whether persistent
        	memory is used as volatile memory. Pmemcheck is loosely based on
		    Memcheck.
        </p>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="pmc-manual.functionality"></a>14.1.1. Functionality</h3></div></div></div>
<p>
                Pmemcheck instruments client code and tracks all stores
    			made to a user provided range of memory addresses.
    			Writing applications which make use of persistent
    			memory prove to be a challenge, because memory is not
    			reclaimed automatically on reboot. Because of
    			the specific nature of persistent memory, the store scheme
    			has to follow a special pattern. To make the data persistent,
    			preferrably in a failsafe manner, you have to do a
    			<span class="emphasis"><em>STORE-&gt;FLUSH-&gt;SFENCE-&gt;PCOMMIT-&gt;SFENCE</em></span>
    			sequence. Pmemcheck checks if this particular sequence of
    			operations is made to any of the registered persistent memory
    			regions. On program exit pmemcheck informs
    			of all improperly made stores by providing the address,
    			size and state of the store. Additionally if debug
    			information is available, the stack trace of the
    			offending write will be shown. The available states are:
            </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem"><p><code class="option">DIRTY</code> - a write has been made</p></li>
<li class="listitem"><p><code class="option">FLUSHED</code> - the write has been
					flushed</p></li>
<li class="listitem"><p><code class="option">FENCED</code> - a store fence has
					been issued after the flush</p></li>
<li class="listitem"><p><code class="option">COMMITED</code> - a PCOMMIT
					instruction has been issued after the fence</p></li>
</ul></div>
<p>
                For more information on persistent memory programming, please visit
                <a class="ulink" href="http://pmem.io" target="_top">pmem.io</a>.
            </p>
<p>
                The tool, when run with the <code class="option"><a class="xref" href="pmc-manual.html#opt.mult-stores">--mult-stores</a>
                </code> option, can also track multiple stores to the same location
                before the data is made persistent - goes through all the states in the
    			right order. This might indicate that there is something wrong with your
                application, because you are using persistent memory as volatile memory.
                If this is the desired use, you can remove the volatile region from
    			analysis using the <code class="option"><a class="xref" href="pmc-manual.html#crm.rem_pmem">VALGRIND_PMC_REMOVE_PMEM_MAPPING</a></code> macro.
            </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="pmc-manual.basic_usage"></a>14.1.2. Basic Usage</h3></div></div></div>
<p>
                As with most other Valgrind tools, compiling your program with debugging
                info (the <code class="option">-g</code> option) provides the most valuable output.
            </p>
<p>
                To run your program under pmemcheck execute:
                </p>
<pre class="screen">valgrind --tool=pmemcheck [pmemcheck options] your_program [program options]</pre>
<p>
            </p>
<p>
                For the tool to be able to correctly inspect your program, you should inform it
                about the persistent memory specific operations your application performs. At the
                moment, pmemcheck does not automatically recognize persistent memory regions,
                appropriate flushes, fences or pcommits. Your code has to use special macros
                specified in <a class="xref" href="pmc-manual.html#pmc-manual.client_requests" title="14.3. Pmemcheck Client Requests">Pmemcheck Client Requests</a>.
            </p>
<p>
                Pmemcheck also has a logging functionality, which when enabled, logs all persistent
                memory relevant macros as well as all stores made to the registered persistent memory
                regions. This is especially useful for any kind of postprocessing. To turn this
                option on, run pmemcheck with <a class="xref" href="pmc-manual.html#opt.log-stores">--log-stores</a>.
            </p>
</div>
<div class="sect2">
<div class="titlepage"><div><div><h3 class="title">
<a name="pmc-manual.error_types"></a>14.1.3. Pmemcheck error types</h3></div></div></div>
<p>
                Pmemcheck is able to catch a couple of possible errors related to programming using
                persistent memory. The most probable is that some stores are never made persistent,
                which together with power failures, may leave the persistent memory in an inconsistent
                state. If debugging symbols are available, the output of such an error looks like this:
                </p>
<pre class="programlisting">
Number of stores not made persistent: 3
Stores not made persistent properly:
[0]    at 0x1234: main (state_machine2.c:28)
	Address: 0x12345	size: 1	state: FENCED
[1]    at 0x1235: main (state_machine2.c:31)
	Address: 0x12346	size: 2	state: FLUSHED
[2]    at 0x1236: main (state_machine2.c:33)
	Address: 0x12347	size: 4	state: DIRTY
Total memory not made persistent: 7</pre>
<p>
                This indicates that three stores made to persistent memory are not guaranteed to be
                durable in case of power failure. The offending stores are identified by a full stack
                trace and the state of the store at program exit is shown. However, be aware that having
                a clean output does <span class="emphasis"><em>NOT</em></span> make your program fail-safe. Additional tools
                have to be used to verify whether your use of persistent memory is correct in case of
                unforseen failures.
            </p>
<p>
                Pmemcheck, when run with the <a class="xref" href="pmc-manual.html#opt.mult-stores">--mult-stores</a> option, can also detect multiple
                stores made to the same persistent memory address before the first store has been made persistent.
                This can indicate an issue with your algorithm, where you overwrite a value multiple times, possibly
                unintentionally. The use of this option is connected with setting the <a class="xref" href="pmc-manual.html#opt.indiff">--indiff</a>
                value. Some implementations of for example <code class="computeroutput">memcpy()</code>, write the same
                data multiple times to the same location. The <a class="xref" href="pmc-manual.html#opt.indiff">--indiff</a> option tells pmemcheck
                between how many Valgrind SuperBlocks, multiple stores with the same value, size and address are to
                be ignored. An example output:</p>
<pre class="programlisting">
Number of stores not made persistent: 1
Stores not made persistent properly:
[0]    at 0x1234: main (multiple_stores.c:33)
	Address: 0x12345	size: 8	state: DIRTY
Total memory not made persistent: 8

Number of overwritten stores: 3
Overwritten stores before they were made persistent:
[0]    at 0x1235: main (multiple_stores.c:30)
	Address: 0x12345	size: 1	state: DIRTY
[1]    at 0x1236: main (multiple_stores.c:31)
	Address: 0x12345	size: 2	state: DIRTY
[2]    at 0x1237: main (multiple_stores.c:32)
	Address: 0x12345	size: 4	state: DIRTY</pre>
<p>
                If the values or sizes are different, or the stores overlap somehow, the event will be recorded
                regardless of the <a class="xref" href="pmc-manual.html#opt.indiff">--indiff</a> value.
            </p>
</div>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="pmc-manual.options"></a>14.2. Pmemcheck Command-line Options</h2></div></div></div>
<p>Pmemcheck-specific command-line options are:</p>
<div class="variablelist">
<a name="pmc.opts.list"></a><dl class="variablelist">
<dt>
<a name="opt.indiff"></a><span class="term">
					<code class="option">--indiff=&lt;uint&gt; [default: 0 SBlocks] </code>
				</span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="opt.mult-stores"></a><span class="term">
					<code class="option">--mult-stores=&lt;no|yes&gt; [default: no] </code>
				</span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="opt.log-stores"></a><span class="term">
					<code class="option">--log-stores=&lt;no|yes&gt; [default: no] </code>
				</span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="opt.print-summary"></a><span class="term">
					<code class="option">--print-summary=&lt;no|yes&gt; [default: yes] </code>
				</span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="opt.flush-check"></a><span class="term">
                    <code class="option">--flush-check=&lt;no|yes&gt; [default: no] </code>
                </span>
</dt>
<dd><p>TODO</p></dd>
</dl>
</div>
</div>
<div class="sect1">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="pmc-manual.client_requests"></a>14.3. Pmemcheck Client Requests</h2></div></div></div>
<p>Pmemcheck-specific client requests are:</p>
<div class="variablelist">
<a name="pmc.crm.list"></a><dl class="variablelist">
<dt>
<a name="crm.reg_pmem"></a><span class="term">
					<code class="option">VALGRIND_PMC_REGISTER_PMEM_MAPPING(addr, size) </code>
				</span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.reg_file"></a><span class="term">
					<code class="option">VALGRIND_PMC_REGISTER_PMEM_FILE(desc, addr_base, size, offset)</code>
				</span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.rem_pmem"></a><span class="term">
					<code class="option">VALGRIND_PMC_REMOVE_PMEM_MAPPING(addr, size) </code>
				</span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.is_pmem"></a><span class="term">
					<code class="option">VALGRIND_PMC_CHECK_IS_PMEM_MAPPING(addr, size) </code>
				</span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.print_map"></a><span class="term">
					<code class="option">VALGRIND_PMC_PRINT_PMEM_MAPPINGS</code>
				</span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.cl_flush"></a><span class="term">
					<code class="option">VALGRIND_PMC_DO_CLFLUSH(addr, size)</code>
				</span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.fence"></a><span class="term">
					<code class="option">VALGRIND_PMC_DO_FENCE</code>
				</span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.commit"></a><span class="term">
					<code class="option">VALGRIND_PMC_DO_COMMIT</code>
				</span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.wr_stats"></a><span class="term">
					<code class="option">VALGRIND_PMC_WRITE_STATS</code>
				</span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.log_on"></a><span class="term">
                    <code class="option">VALGRIND_PMC_LOG_STORES</code>
                </span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.log_stop"></a><span class="term">
                    <code class="option">VALGRIND_PMC_NO_LOG_STORES</code>
                </span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.add_log_reg"></a><span class="term">
					<code class="option">VALGRIND_PMC_ADD_LOG_REGION(addr, size)</code>
				</span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.rm_log_reg"></a><span class="term">
                    <code class="option">VALGRIND_PMC_REMOVE_LOG_REGION(addr, size)</code>
                </span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.full_reor"></a><span class="term">
                    <code class="option">VALGRIND_PMC_FULL_REORDER</code>
                </span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.part_reor"></a><span class="term">
                    <code class="option">VALGRIND_PMC_PARTIAL_REORDER</code>
                </span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.fault_only"></a><span class="term">
                    <code class="option">VALGRIND_PMC_ONLY_FAULT</code>
                </span>
</dt>
<dd><p>TODO</p></dd>
<dt>
<a name="crm.no_fault"></a><span class="term">
                    <code class="option">VALGRIND_PMC_STOP_REORDER_FAULT</code>
                </span>
</dt>
<dd><p>TODO</p></dd>
</dl>
</div>
</div>
<div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="pmc-manual.monitor_commands"></a>14.4. Pmemcheck Monitor Commands</h2></div></div></div></div>
<p>The Pmemcheck tool provides monitor commands handled by the Valgrind
            gdbserver (see <a class="xref" href="manual-core-adv.html#manual-core-adv.gdbserver-commandhandling" title="3.2.5. Monitor command handling by the Valgrind gdbserver">Monitor command handling by the Valgrind gdbserver</a>).
            Tool specific monitor commands are:</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem"><p><code class="varname">help</code> prints monitor help message.</p></li>
<li class="listitem"><p><code class="varname">print_stats</code> prints pmemcheck statistics
                    registered.</p></li>
<li class="listitem"><p><code class="varname">print_pmem_regions</code> prints registered
                    persistent memory regions.</p></li>
<li class="listitem"><p><code class="varname">print_log_regions</code> prints registered
                    loggable persistent memory regions.</p></li>
</ul></div>
</div>
<div>
<br><table class="nav" width="100%" cellspacing="3" cellpadding="2" border="0" summary="Navigation footer">
<tr>
<td rowspan="2" width="40%" align="left">
<a accesskey="p" href="lk-manual.html">&lt;&lt; 13. Lackey: an example tool</a> </td>
<td width="20%" align="center"><a accesskey="u" href="manual.html">Up</a></td>
<td rowspan="2" width="40%" align="right"> <a accesskey="n" href="nl-manual.html">15. Nulgrind: the minimal Valgrind tool &gt;&gt;</a>
</td>
</tr>
<tr><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td></tr>
</table>
</div>
</body>
</html>
